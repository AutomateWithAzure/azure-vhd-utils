package main

import (
	"gopkg.in/urfave/cli.v1"
	"log"
	"os"
)

func main() {
	app := cli.NewApp()
	app.Name = "vhd"
	app.Usage = "Commands to manage VHDs"

	// global level flags
	app.Flags = []cli.Flag{
		cli.BoolFlag{
			Name:  "verbose",
			Usage: "Show more output",
		},
	}

	app.Commands = []cli.Command{
		vhdInspectCmdHandler(),
		vhdUploadCmdHandler(),
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatalln(err)
	}
}
package main

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"os"
	"strconv"
	"text/template"

	"github.com/Microsoft/azure-vhd-utils/vhdcore"
	"github.com/Microsoft/azure-vhd-utils/vhdcore/block/bitmap"
	"github.com/Microsoft/azure-vhd-utils/vhdcore/footer"
	"github.com/Microsoft/azure-vhd-utils/vhdcore/vhdfile"
	"gopkg.in/urfave/cli.v1"
)

// FixedDiskBlocksInfo type describes general block information of a fixed disk
//
type FixedDiskBlocksInfo struct {
	BlockSize  int64
	BlockCount int64
}

// ExpandableDiskBlocksInfo type describes general block information of a expandable disk
//
type ExpandableDiskBlocksInfo struct {
	BlockDataSize         int64
	BlockBitmapSize       int32
	BlockBitmapPaddedSize int32
	BlockCount            int64
	UsedBlockCount        int64
	EmptyBlockCount       int64
}

func vhdInspectCmdHandler() cli.Command {
	return cli.Command{
		Name:  "inspect",
		Usage: "Commands to inspect local VHD",
		Subcommands: []cli.Command{
			{
				Name:  "header",
				Usage: "Show VHD header",
				Flags: []cli.Flag{
					cli.StringFlag{
						Name:  "path",
						Usage: "Path to VHD.",
					},
				},
				Action: showVhdHeader,
			},
			{
				Name:  "footer",
				Usage: "Show VHD footer",
				Flags: []cli.Flag{
					cli.StringFlag{
						Name:  "path",
						Usage: "Path to VHD.",
					},
				},
				Action: showVhdFooter,
			},
			{
				Name:  "bat",
				Usage: "Show a range of VHD Block allocation table (BAT) entries",
				Flags: []cli.Flag{
					cli.StringFlag{
						Name:  "path",
						Usage: "Path to VHD.",
					},
					cli.StringFlag{
						Name:  "start-range",
						Usage: "Start range.",
					},
					cli.StringFlag{
						Name:  "end-range",
						Usage: "End range.",
					},
					cli.BoolFlag{
						Name:  "skip-empty",
						Usage: "Do not show BAT entries pointing to empty blocks.",
					},
				},
				Action: showVhdBAT,
			},
			{
				Name:  "block",
				Usage: "Inspect VHD blocks",
				Subcommands: []cli.Command{
					{
						Name:  "info",
						Usage: "Show blocks general information",
						Flags: []cli.Flag{
							cli.StringFlag{
								Name:  "path",
								Usage: "Path to VHD.",
							},
						},
						Action: showVhdBlocksInfo,
					},
					{
						Name:  "bitmap",
						Usage: "Show sector bitmap of a expandable disk's block",
						Flags: []cli.Flag{
							cli.StringFlag{
								Name:  "path",
								Usage: "Path to VHD.",
							},
							cli.StringFlag{
								Name:  "block-index",
								Usage: "Index of the block.",
							},
						},
						Action: showVhdBlockBitmap,
					},
				},
			},
		},
	}
}

const headerTempl = `Cookie            : {{.Cookie }}
DataOffset        : {{.DataOffset}}
TableOffset       : {{.TableOffset}}
HeaderVersion     : {{.HeaderVersion}}
MaxTableEntries   : {{.MaxTableEntries}}
BlockSize         : {{.BlockSize}} bytes
CheckSum          : {{.CheckSum}}
ParentUniqueID    : {{.ParentUniqueID}}
ParentTimeStamp   : {{.ParentTimeStamp | printf "%v"}}
Reserved          : {{.Reserved}}
ParentPath        : {{.ParentPath}}
{{range .ParentLocators}}
  PlatformCode               : {{.PlatformCode}}
  PlatformDataSpace          : {{.PlatformDataSpace}}
  PlatformDataLength         : {{.PlatformDataLength}}
  Reserved                   : {{.Reserved}}
  PlatformDataOffset         : {{.PlatformDataOffset}}
  PlatformSpecificFileLocator: {{.PlatformSpecificFileLocator}}
{{end}}

-- Hex dump --

{{.RawData | dump }}`

func showVhdHeader(c *cli.Context) error {
	vhdPath := c.String("path")
	if vhdPath == "" {
		return errors.New("Missing required argument --path")
	}

	vFileFactory := &vhdfile.FileFactory{}
	vFile, err := vFileFactory.Create(vhdPath)
	if err != nil {
		return err
	}

	defer vFileFactory.Dispose(nil)
	if vFile.GetDiskType() == footer.DiskTypeFixed {
		return errors.New("Warn: Only expandable VHDs has header structure, this is a fixed VHD")
	}

	t, err := template.New("root").
		Funcs(template.FuncMap{"dump": hex.Dump}).
		Parse(headerTempl)
	t.Execute(os.Stdout, vFile.Header)

	return nil
}

const footerTempl = `Cookie            : {{.Cookie }}
Features          : {{.Features}}
FileFormatVersion : {{.FileFormatVersion}}
HeaderOffset      : {{.HeaderOffset}}
TimeStamp         : {{.TimeStamp | printf "%v" }}
CreatorApplication: {{.CreatorApplication}}
CreatorVersion    : {{.CreatorVersion}}
CreatorHostOsType : {{.CreatorHostOsType}}
PhysicalSize      : {{.PhysicalSize}} bytes
VirtualSize       : {{.VirtualSize}} bytes
DiskGeometry      : {{.DiskGeometry}}
DiskType          : {{.DiskType}}
CheckSum          : {{.CheckSum}}
UniqueID          : {{.UniqueID}}
SavedState        : {{.SavedState | printf "%v" }}

-- Hex dump --

{{.RawData | dump }}`

func showVhdFooter(c *cli.Context) error {
	vhdPath := c.String("path")
	if vhdPath == "" {
		return errors.New("Missing required argument --path")
	}

	vFileFactory := &vhdfile.FileFactory{}
	vFile, err := vFileFactory.Create(vhdPath)
	if err != nil {
		return err
	}

	defer vFileFactory.Dispose(nil)
	t, err := template.New("root").
		Funcs(template.FuncMap{"dump": hex.Dump}).
		Parse(footerTempl)
	t.Execute(os.Stdout, vFile.Footer)

	return nil
}

const batTempl = `{{range $index, $value := .}} BAT[{{adj $index}}] : {{$value | printf "0x%X"}}
{{end}}`

func showVhdBAT(c *cli.Context) error {
	vhdPath := c.String("path")
	if vhdPath == "" {
		return errors.New("Missing required argument --path")
	}

	startRange := uint32(0)
	var err error
	if c.IsSet("start-range") {
		r, err := strconv.ParseUint(c.String("start-range"), 10, 32)
		if err != nil {
			return fmt.Errorf("invalid index value --start-range: %s", err)
		}
		startRange = uint32(r)
	}

	endRange := uint32(0)
	if c.IsSet("end-range") {
		r, err := strconv.ParseUint(c.String("end-range"), 10, 32)
		if err != nil {
			return fmt.Errorf("invalid index value --end-range: %s", err)
		}
		endRange = uint32(r)
	}

	vFileFactory := &vhdfile.FileFactory{}
	vFile, err := vFileFactory.Create(vhdPath)
	if err != nil {
		return err
	}

	defer vFileFactory.Dispose(nil)
	if vFile.GetDiskType() == footer.DiskTypeFixed {
		return errors.New("Warn: Only expandable VHDs has Block Allocation Table, this is a fixed VHD")
	}

	maxEntries := vFile.BlockAllocationTable.BATEntriesCount
	if !c.IsSet("end-range") {
		endRange = maxEntries - 1
	}

	if startRange > maxEntries || endRange > maxEntries {
		return fmt.Errorf("index out of boundary, this vhd BAT index range is [0, %d]", maxEntries)
	}

	if startRange > endRange {
		return errors.New("invalid range --start-range > --end-range")
	}

	fMap := template.FuncMap{
		"adj": func(i int) int {
			return i + int(startRange)
		},
	}

	t, _ := template.New("root").
		Funcs(fMap).
		Parse(batTempl)

	if !c.IsSet("skip-empty") {
		t.Execute(os.Stdout, vFile.BlockAllocationTable.BAT[startRange:endRange+1])
	} else {
		nonEmptyBATEntries := make(map[int]uint32)
		for blockIndex := startRange; blockIndex <= endRange; blockIndex++ {
			if vFile.BlockAllocationTable.HasData(blockIndex) {
				nonEmptyBATEntries[int(blockIndex-startRange)] = vFile.BlockAllocationTable.BAT[blockIndex]
			}
		}

		t.Execute(os.Stdout, nonEmptyBATEntries)
	}

	return nil
}

const fixedDiskBlockInfoTempl = `Block sector size : 512 bytes
Block size        : {{.BlockSize}} bytes
Total blocks      : {{.BlockCount}}
`

const expandableDiskBlockInfoTempl = `Block sector size                  : 512 bytes
Block data section size            : {{.BlockDataSize}} bytes
Block bitmap section size          : {{.BlockBitmapSize}} bytes
Block bitmap section size (padded) : {{.BlockBitmapPaddedSize}} bytes
Total blocks                       : {{.BlockCount}} (Used: {{.UsedBlockCount}} Empty: {{.EmptyBlockCount}})
`

func showVhdBlocksInfo(c *cli.Context) error {
	vhdPath := c.String("path")
	if vhdPath == "" {
		return errors.New("Missing required argument --path")
	}

	vFileFactory := &vhdfile.FileFactory{}
	vFile, err := vFileFactory.Create(vhdPath)
	if err != nil {
		panic(err)
	}
	defer vFileFactory.Dispose(nil)

	vBlockFactory, err := vFile.GetBlockFactory()
	if err != nil {
		return err
	}

	if vFile.GetDiskType() == footer.DiskTypeFixed {
		info := &FixedDiskBlocksInfo{
			BlockSize:  vBlockFactory.GetBlockSize(),
			BlockCount: vBlockFactory.GetBlockCount(),
		}
		// Note: Identifying empty and used blocks of a FixedDisk requires reading each
		// block and checking it contains all zeros, which is time consuming so we don't
		// show those information.
		t, err := template.New("root").
			Parse(fixedDiskBlockInfoTempl)
		if err != nil {
			return err
		}
		t.Execute(os.Stdout, info)
	} else {
		info := &ExpandableDiskBlocksInfo{
			BlockDataSize:         vBlockFactory.GetBlockSize(),
			BlockBitmapSize:       vFile.BlockAllocationTable.GetBitmapSizeInBytes(),
			BlockBitmapPaddedSize: vFile.BlockAllocationTable.GetSectorPaddedBitmapSizeInBytes(),
			BlockCount:            vBlockFactory.GetBlockCount(),
		}

		for _, v := range vFile.BlockAllocationTable.BAT {
			if v == vhdcore.VhdNoDataInt {
				info.EmptyBlockCount++
			} else {
				info.UsedBlockCount++
			}
		}

		t, err := template.New("root").
			Parse(expandableDiskBlockInfoTempl)
		if err != nil {
			return err
		}
		t.Execute(os.Stdout, info)
	}

	return nil
}

func showVhdBlockBitmap(c *cli.Context) error {
	const bytesPerLine int32 = 8
	const bitsPerLine int32 = 8 * bytesPerLine

	vhdPath := c.String("path")
	if vhdPath == "" {
		return errors.New("missing required argument --path")
	}

	if !c.IsSet("block-index") {
		return errors.New("missing required argument --block-index")
	}

	blockIndex := uint32(0)
	id, err := strconv.ParseUint(c.String("block-index"), 10, 32)
	if err != nil {
		return fmt.Errorf("invalid index value --block-index: %s", err)
	}
	blockIndex = uint32(id)

	vFileFactory := &vhdfile.FileFactory{}
	vFile, err := vFileFactory.Create(vhdPath)
	if err != nil {
		return err
	}
	defer vFileFactory.Dispose(nil)

	if vFile.GetDiskType() == footer.DiskTypeFixed {
		return errors.New("warn: only expandable VHDs has bitmap associated with blocks, this is a fixed VHD")
	}

	vBlockFactory, err := vFile.GetBlockFactory()
	if err != nil {
		return err
	}

	if int64(blockIndex) > vBlockFactory.GetBlockCount()-1 {
		return fmt.Errorf("warn: given block index %d is out of boundary, block index range is [0 : %d]", blockIndex, vBlockFactory.GetBlockCount()-1)
	}

	vBlock, err := vBlockFactory.Create(blockIndex)
	if err != nil {
		return err
	}

	if vBlock.IsEmpty {
		fmt.Print("The block that this bitmap belongs to is marked as empty\n\n")
		fmt.Print(createEmptyBitmapString(bytesPerLine, bitsPerLine, vFile.BlockAllocationTable.GetBitmapSizeInBytes()))
		return nil
	}

	fmt.Print(createBitmapString(bitsPerLine, vBlock.BitMap))
	return nil
}

func createEmptyBitmapString(bytesPerLine, bitsPerLine, bitmapSizeInBytes int32) string {
	var buffer bytes.Buffer
	line := ""
	for i := int32(0); i < bytesPerLine; i++ {
		line = line + " " + "00000000"
	}

	count := bitmapSizeInBytes / bytesPerLine
	pad := len(strconv.FormatInt(int64(bitmapSizeInBytes*8), 10))
	fmtLine := fmt.Sprintf("[%%-%dd - %%%dd]", pad, pad)
	for i := int32(0); i < count; i++ {
		buffer.WriteString(fmt.Sprintf(fmtLine, i*bitsPerLine, i*bitsPerLine+bitsPerLine-1))
		buffer.WriteString(line)
		buffer.WriteString("\n")
	}

	remaining := bitmapSizeInBytes % bytesPerLine
	if remaining != 0 {
		buffer.WriteString(fmt.Sprintf(fmtLine, count*bitsPerLine, count*bitsPerLine+8*remaining-1))
		for i := int32(0); i < remaining; i++ {
			buffer.WriteString(" 00000000")
		}
	}

	buffer.WriteString("\n")
	return buffer.String()
}

func createBitmapString(bitsPerLine int32, vBlockBitmap *bitmap.BitMap) string {
	var buffer bytes.Buffer
	pad := len(strconv.FormatInt(int64(vBlockBitmap.Length), 10))
	fmtLine := fmt.Sprintf("[%%-%dd - %%%dd]", pad, pad)
	for i := int32(0); i < vBlockBitmap.Length; {
		if i%bitsPerLine == 0 {
			if i < vBlockBitmap.Length-bitsPerLine {
				buffer.WriteString(fmt.Sprintf(fmtLine, i, i+bitsPerLine-1))
			} else {
				buffer.WriteString(fmt.Sprintf(fmtLine, i, vBlockBitmap.Length-1))
			}
		}

		b := byte(0)
		for j := uint32(0); j < 8; j++ {
			if dirty, _ := vBlockBitmap.Get(i); dirty {
				b |= byte(1 << (7 - j))
			}
			i++
		}
		buffer.WriteByte(' ')
		buffer.WriteString(fmt.Sprintf("%08b", b))
		if i%bitsPerLine == 0 {
			buffer.WriteString("\n")
		}
	}
	buffer.WriteString("\n")
	return buffer.String()
}
package main

import (
	"encoding/base64"
	"errors"
	"fmt"
	"log"
	"runtime"
	"strconv"
	"strings"

	"github.com/AutomateWithAzure/azure-sdk-for-go/tree/main/storage"
	"github.com/Microsoft/azure-vhd-utils/upload"
	"github.com/Microsoft/azure-vhd-utils/upload/metadata"
	"github.com/Microsoft/azure-vhd-utils/vhdcore/common"
	"github.com/Microsoft/azure-vhd-utils/vhdcore/diskstream"
	"github.com/Microsoft/azure-vhd-utils/vhdcore/validator"
	"gopkg.in/urfave/cli.v1"
)

func vhdUploadCmdHandler() cli.Command {
	return cli.Command{
		Name:  "upload",
		Usage: "Upload a local VHD to Azure storage as page blob",
		Flags: []cli.Flag{
			cli.StringFlag{
				Name:  "localvhdpath",
				Usage: "Path to source VHD in the local machine.",
			},
			cli.StringFlag{
				Name:  "stgaccountname",
				Usage: "Azure storage account name.",
			},
			cli.StringFlag{
				Name:  "stgaccountkey",
				Usage: "Azure storage account key.",
			},
			cli.StringFlag{
				Name:  "containername",
				Usage: "Name of the container holding destination page blob. (Default: vhds)",
			},
			cli.StringFlag{
				Name:  "blobname",
				Usage: "Name of the destination page blob.",
			},
			cli.StringFlag{
				Name:  "parallelism",
				Usage: "Number of concurrent goroutines to be used for upload",
			},
			cli.BoolFlag{
				Name:  "overwrite",
				Usage: "Overwrite the blob if already exists.",
			},
		},
		Action: func(c *cli.Context) error {
			const PageBlobPageSize int64 = 2 * 1024 * 1024

			localVHDPath := c.String("localvhdpath")
			if localVHDPath == "" {
				return errors.New("Missing required argument --localvhdpath")
			}

			stgAccountName := c.String("stgaccountname")
			if stgAccountName == "" {
				return errors.New("Missing required argument --stgaccountname")
			}

			stgAccountKey := c.String("stgaccountkey")
			if stgAccountKey == "" {
				return errors.New("Missing required argument --stgaccountkey")
			}

			containerName := c.String("containername")
			if containerName == "" {
				containerName = "vhds"
				log.Println("Using default container 'vhds'")
			}

			blobName := c.String("blobname")
			if blobName == "" {
				return errors.New("Missing required argument --blobname")
			}

			if !strings.HasSuffix(strings.ToLower(blobName), ".vhd") {
				blobName = blobName + ".vhd"
			}

			parallelism := int(0)
			if c.IsSet("parallelism") {
				p, err := strconv.ParseUint(c.String("parallelism"), 10, 32)
				if err != nil {
					return fmt.Errorf("invalid index value --parallelism: %s", err)
				}
				parallelism = int(p)
			} else {
				parallelism = 8 * runtime.NumCPU()
				log.Printf("Using default parallelism [8*NumCPU] : %d\n", parallelism)
			}

			overwrite := c.IsSet("overwrite")

			ensureVHDSanity(localVHDPath)
			diskStream, err := diskstream.CreateNewDiskStream(localVHDPath)
			if err != nil {
				return err
			}
			defer diskStream.Close()

			storageClient, err := storage.NewBasicClient(stgAccountName, stgAccountKey)
			if err != nil {
				return err
			}
			blobServiceClient := storageClient.GetBlobService()
			if _, err = blobServiceClient.CreateContainerIfNotExists(containerName, storage.ContainerAccessTypePrivate); err != nil {
				return err
			}

			blobExists, err := blobServiceClient.BlobExists(containerName, blobName)
			if err != nil {
				return err
			}

			resume := false
			var blobMetaData *metadata.MetaData
			if blobExists {
				if !overwrite {
					blobMetaData = getBlobMetaData(blobServiceClient, containerName, blobName)
					resume = true
					log.Printf("Blob with name '%s' already exists, checking upload can be resumed\n", blobName)
				}
			}

			localMetaData := getLocalVHDMetaData(localVHDPath)
			var rangesToSkip []*common.IndexRange
			if resume {
				if errs := metadata.CompareMetaData(blobMetaData, localMetaData); len(errs) != 0 {
					printErrorsAndFatal(errs)
				}
				rangesToSkip = getAlreadyUploadedBlobRanges(blobServiceClient, containerName, blobName)
			} else {
				createBlob(blobServiceClient, containerName, blobName, diskStream.GetSize(), localMetaData)
			}

			uploadableRanges, err := upload.LocateUploadableRanges(diskStream, rangesToSkip, PageBlobPageSize)
			if err != nil {
				return err
			}

			uploadableRanges, err = upload.DetectEmptyRanges(diskStream, uploadableRanges)
			if err != nil {
				return err
			}

			cxt := &upload.DiskUploadContext{
				VhdStream:             diskStream,
				UploadableRanges:      uploadableRanges,
				AlreadyProcessedBytes: common.TotalRangeLength(rangesToSkip),
				BlobServiceClient:     blobServiceClient,
				ContainerName:         containerName,
				BlobName:              blobName,
				Parallelism:           parallelism,
				Resume:                resume,
				MD5Hash:               localMetaData.FileMetaData.MD5Hash,
			}

			err = upload.Upload(cxt)
			if err != nil {
				return err
			}

			setBlobMD5Hash(blobServiceClient, containerName, blobName, localMetaData)
			fmt.Println("\nUpload completed")
			return nil
		},
	}
}

// printErrorsAndFatal prints the errors in a slice one by one and then exit
//
func printErrorsAndFatal(errs []error) {
	fmt.Println()
	for _, e := range errs {
		fmt.Println(e)
	}
	log.Fatal("Cannot continue due to above errors.")
}

// ensureVHDSanity ensure is VHD is valid for Azure.
//
func ensureVHDSanity(localVHDPath string) {
	if err := validator.ValidateVhd(localVHDPath); err != nil {
		log.Fatal(err)
	}

	if err := validator.ValidateVhdSize(localVHDPath); err != nil {
		log.Fatal(err)
	}
}

// getBlobMetaData returns the custom metadata associated with a page blob which is set by createBlob method.
// The parameter client is the Azure blob service client, parameter containerName is the name of an existing container
// in which the page blob resides, parameter blobName is name for the page blob
// This method attempt to fetch the metadata only if MD5Hash is not set for the page blob, this method panic if the
// MD5Hash is already set or if the custom metadata is absent.
//
func getBlobMetaData(client storage.BlobStorageClient, containerName, blobName string) *metadata.MetaData {
	md5Hash := getBlobMD5Hash(client, containerName, blobName)
	if md5Hash != "" {
		log.Fatalf("VHD exists in blob storage with name '%s'. If you want to upload again, use the --overwrite option.", blobName)
	}

	blobMetaData, err := metadata.NewMetadataFromBlob(client, containerName, blobName)
	if err != nil {
		log.Fatal(err)
	}

	if blobMetaData == nil {
		log.Fatalf("There is no upload metadata associated with the existing blob '%s', so upload operation cannot be resumed, use --overwrite option.", blobName)
	}
	return blobMetaData
}

// getLocalVHDMetaData returns the metadata of a local VHD
//
func getLocalVHDMetaData(localVHDPath string) *metadata.MetaData {
	localMetaData, err := metadata.NewMetaDataFromLocalVHD(localVHDPath)
	if err != nil {
		log.Fatal(err)
	}
	return localMetaData
}

// createBlob creates a page blob of specific size and sets custom metadata
// The parameter client is the Azure blob service client, parameter containerName is the name of an existing container
// in which the page blob needs to be created, parameter blobName is name for the new page blob, size is the size of
// the new page blob in bytes and parameter vhdMetaData is the custom metadata to be associacted with the page blob
//
func createBlob(client storage.BlobStorageClient, containerName, blobName string, size int64, vhdMetaData *metadata.MetaData) {
	if err := client.PutPageBlob(containerName, blobName, size, nil); err != nil {
		log.Fatal(err)
	}
	m, _ := vhdMetaData.ToMap()
	if err := client.SetBlobMetadata(containerName, blobName, m, make(map[string]string)); err != nil {
		log.Fatal(err)
	}
}

// setBlobMD5Hash sets MD5 hash of the blob in it's properties
//
func setBlobMD5Hash(client storage.BlobStorageClient, containerName, blobName string, vhdMetaData *metadata.MetaData) {
	if vhdMetaData.FileMetaData.MD5Hash != nil {
		blobHeaders := storage.BlobHeaders{
			ContentMD5: base64.StdEncoding.EncodeToString(vhdMetaData.FileMetaData.MD5Hash),
		}
		if err := client.SetBlobProperties(containerName, blobName, blobHeaders); err != nil {
			log.Fatal(err)
		}
	}
}

// getAlreadyUploadedBlobRanges returns the range slice containing ranges of a page blob those are already uploaded.
// The parameter client is the Azure blob service client, parameter containerName is the name of an existing container
// in which the page blob resides, parameter blobName is name for the page blob
//
func getAlreadyUploadedBlobRanges(client storage.BlobStorageClient, containerName, blobName string) []*common.IndexRange {
	existingRanges, err := client.GetPageRanges(containerName, blobName)
	if err != nil {
		log.Fatal(err)
	}
	var rangesToSkip = make([]*common.IndexRange, len(existingRanges.PageList))
	for i, r := range existingRanges.PageList {
		rangesToSkip[i] = common.NewIndexRange(r.Start, r.End)
	}
	return rangesToSkip
}

// getBlobMD5Hash returns the MD5Hash associated with a blob
// The parameter client is the Azure blob service client, parameter containerName is the name of an existing container
// in which the page blob resides, parameter blobName is name for the page blob
//
func getBlobMD5Hash(client storage.BlobStorageClient, containerName, blobName string) string {
	properties, err := client.GetBlobProperties(containerName, blobName)
	if err != nil {
		log.Fatal(err)
	}
	return properties.ContentMD5
}
